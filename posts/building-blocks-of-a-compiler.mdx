---
title: "Building Blocks of a Compiler"
description: "A Journey Through My Toy Language"
date: "2023-07-29"
tags: ['compiler']
---

## Basic idea

In this post, I'll explain basic concepts about compilers and interpreters. The idea is to dive into a simple 
implementation of a toy language I did to see and understand how compilers and interpreters work under the hood.

## The parts of a language

Below are all the most common parts that almost every compiler/interpreter has; I'll try to explain each one.

- Lexing
- Parsing
- Static analysis
- Intermediate representation
- Optimization
- Code generation and/or runtime

## Lexing

Lexing, or lexical analysis, is the first phase of a compiler. It's a process where the compiler breaks down the source code, 
a string of characters, into meaningful elements called tokens.

Tokens are minor units that have standalone meanings. They can represent variable names, data types, function names, operators, 
keywords, punctuation like semicolons or brackets, and more.

The lexer scans the source code, character by character. When it identifies a sequence of characters that forms a valid token, 
it generates that token. For example, if the lexer encounters the characters "i", "n", and "t" in sequence and not part of a 
more extensive sequence of characters like the word "print", it generates a token for the keyword "int".

However, not all sequences of characters in the source code help understand the program's structure or behavior. The lexer 
typically discards sequences like whitespace and comments or categorizes them as a unique token.

Here you can see the basic lexer implementation that I did for the toy language that I wrote for this post:

```ts
import { Type } from "./checker";
import {
  dropFromString,
  isAlphaNum,
  isDigit,
  isLetter,
  take,
  takeWhile,
} from "./utils";

export type OP =
  | "+"
  | "-"
  | "*"
  | "/"
  | "%"
  | "<"
  | ">"
  | "=="
  | "!="
  | "<="
  | ">=";

export type Token =
  | { type: "Literal"; value: string }
  | { type: "String"; value: string }
  | { type: "Number"; value: number }
  | { type: "Boolean"; value: boolean }
  | { type: "TypeDeclaration"; tyValue: Type }
  | { type: "VariableDeclaration" }
  | { type: "Equal" }
  | { type: "FunctionDeclaration" }
  | { type: "OpenParentheses" }
  | { type: "CloseParentheses" }
  | { type: "Comma" }
  | { type: "OpenCurlyBracket" }
  | { type: "CloseCurlyBracket" }
  | { type: "Return" }
  | { type: "IfDeclaration" }
  | { type: "OP"; value: OP }
  | { type: "Colon" }
  | { type: "Arrow" }
  | { type: "SemiColon" };

export type TokenType = Token["type"];

export const tokenToString = (token: Token): string => {
  if (token.type === "TypeDeclaration") {
    return token.tyValue.type;
  }

  if (token.type === "VariableDeclaration") {
    return "cria";
  }

  if (token.type === "Equal") {
    return "=";
  }

  if (token.type === "FunctionDeclaration") {
    return "pegaVisao";
  }

  if (token.type === "OpenParentheses") {
    return "(";
  }

  if (token.type === "CloseParentheses") {
    return ")";
  }

  if (token.type === "Comma") {
    return ",";
  }

  if (token.type === "OpenCurlyBracket") {
    return "{";
  }

  if (token.type === "CloseCurlyBracket") {
    return "}";
  }

  if (token.type === "Return") {
    return "tomali";
  }

  if (token.type === "IfDeclaration") {
    return "qualfoi?";
  }

  if (token.type === "Colon") {
    return ":";
  }

  if (token.type === "Arrow") {
    return "=>";
  }

  if (token.type === "SemiColon") {
    return ";";
  }

  return String(token.value);
};

export const takeLiteral = (str: string): [string, string] => {
  const literal = takeWhile(
    str,
    (c) => isAlphaNum(c) || c === "_" || c === "-"
  );
  const rest = dropFromString(str, literal.length);

  return [literal, rest];
};

export const takeString = (str: string): [string, string] => {
  const strWithoutFirstQuote = dropFromString(str, 1);

  const string = takeWhile(strWithoutFirstQuote, (c) => c !== '"' && c !== "'");
  const rest = dropFromString(strWithoutFirstQuote, string.length + 1);

  return [string, rest];
};

export const takeNumber = (str: string): [number, string] => {
  const number = takeWhile(str, (c) => isDigit(c));
  const rest = dropFromString(str, number.length);

  return [Number(number), rest];
};

export const lexer = (str: string): Token[] => {
  if (!str[0]) return [];

  const current = str[0];

  if (isDigit(current)) {
    const [number, rest] = takeNumber(str);

    return [{ type: "Number", value: number }, ...lexer(rest)];
  } else if (isLetter(current)) {
    if (current === "c" && take(str, 4) === "cria") {
      return [
        { type: "VariableDeclaration" },
        ...lexer(dropFromString(str, 4)),
      ];
    }

    if (current === "p" && take(str, 9) === "pegaVisao") {
      return [
        { type: "FunctionDeclaration" },
        ...lexer(dropFromString(str, 9)),
      ];
    }

    if (current === "t" && take(str, 6) === "tomali") {
      return [{ type: "Return" }, ...lexer(dropFromString(str, 6))];
    }

    if (current === "t" && take(str, 4) === "true") {
      return [
        { type: "Boolean", value: true },
        ...lexer(dropFromString(str, 4)),
      ];
    }

    if (current === "f" && take(str, 5) === "false") {
      return [
        { type: "Boolean", value: false },
        ...lexer(dropFromString(str, 5)),
      ];
    }

    if (current === "q" && take(str, 8) === "qualfoi?") {
      return [{ type: "IfDeclaration" }, ...lexer(dropFromString(str, 8))];
    }

    if (current === "s" && take(str, 6) === "string") {
      return [
        { type: "TypeDeclaration", tyValue: { type: "String" } },
        ...lexer(dropFromString(str, 6)),
      ];
    }

    if (current === "n" && take(str, 6) === "number") {
      return [
        { type: "TypeDeclaration", tyValue: { type: "Number" } },
        ...lexer(dropFromString(str, 6)),
      ];
    }

    if (current === "b" && take(str, 7) === "boolean") {
      return [
        { type: "TypeDeclaration", tyValue: { type: "Boolean" } },
        ...lexer(dropFromString(str, 7)),
      ];
    }

    const [literal, rest] = takeLiteral(str);

    return [{ type: "Literal", value: literal }, ...lexer(rest)];
  } else {
    const xs = dropFromString(str, 1);

    if (current === '"' || current === "'") {
      const [string, rest] = takeString(str);

      return [{ type: "String", value: string }, ...lexer(rest)];
    }

    if (current === "=" && take(str, 2) === "=>") {
      return [{ type: "Arrow" }, ...lexer(dropFromString(str, 2))];
    }

    if (current === "=" && take(str, 2) === "==") {
      return [{ type: "OP", value: "==" }, ...lexer(dropFromString(str, 2))];
    }

    if (current === "=") {
      return [{ type: "Equal" }, ...lexer(xs)];
    }

    if (current === "(") {
      return [{ type: "OpenParentheses" }, ...lexer(xs)];
    }

    if (current === ")") {
      return [{ type: "CloseParentheses" }, ...lexer(xs)];
    }

    if (current === ",") {
      return [{ type: "Comma" }, ...lexer(xs)];
    }

    if (current === "{") {
      return [{ type: "OpenCurlyBracket" }, ...lexer(xs)];
    }

    if (current === "}") {
      return [{ type: "CloseCurlyBracket" }, ...lexer(xs)];
    }

    if (current === "!" && take(str, 2) === "!=") {
      return [{ type: "OP", value: "!=" }, ...lexer(dropFromString(str, 2))];
    }

    if (current === "+") {
      return [{ type: "OP", value: "+" }, ...lexer(xs)];
    }

    if (current === "-") {
      return [{ type: "OP", value: "-" }, ...lexer(xs)];
    }

    if (current === "*") {
      return [{ type: "OP", value: "*" }, ...lexer(xs)];
    }

    if (current === "/") {
      return [{ type: "OP", value: "/" }, ...lexer(xs)];
    }

    if (current === "%") {
      return [{ type: "OP", value: "%" }, ...lexer(xs)];
    }

    if (current === ">" && take(str, 2) === ">=") {
      return [{ type: "OP", value: ">=" }, ...lexer(dropFromString(str, 2))];
    }

    if (current === ">") {
      return [{ type: "OP", value: ">" }, ...lexer(xs)];
    }

    if (current === "<" && take(str, 2) === "<=") {
      return [{ type: "OP", value: "<=" }, ...lexer(dropFromString(str, 2))];
    }

    if (current === "<") {
      return [{ type: "OP", value: "<" }, ...lexer(xs)];
    }

    if (current === ":") {
      return [{ type: "Colon" }, ...lexer(xs)];
    }

    if (current === ";") {
      return [{ type: "SemiColon" }, ...lexer(xs)];
    }

    return lexer(xs);
  }
};
```

Just a note: This lexer could be way more efficient and faster; I did it to make it work as simply as possible.

## Parsing

After the lexing phase of a compiler, which produces a series of tokens, we move on to the parsing phase. Parsing, 
or syntax analysis, takes these tokens and organizes them into a more complex structure, typically known as an abstract syntax tree (aka AST).

In parsing, the compiler checks that the program follows the language's syntax rules. It uses these rules to build the parse tree, 
a hierarchical structure that represents the organization of the code. Each tree node represents a construct in the language, 
such as an "if" statement or a loop.

This phase usually identifies and reports syntax errors, like a missing semicolon or an unmatched bracket. 
If the parser finds a syntax error, it typically stops further processing and reports the error to the user.

By the end of the parsing phase, if no errors are detected, the compiler has a structured representation of the source code.

Below you can see the basic parser implementation that I did.

First, we define our AST:

```ts
import { Type } from "./checker";
import { OP } from "./lexer";

export type Expr =
  | { type: "Literal"; value: string }
  | { type: "String"; value: string }
  | { type: "Number"; value: number }
  | { type: "Boolean"; value: boolean }
  | { type: "Variable"; name: string; value: Expr }
  | { type: "Function"; name: string; params: { name: string, ty: Type }[]; body: Expr[]; returnTy: Type }
  | { type: "FunctionApp"; functionName: string; params: Expr[] }
  | { type: "ReturnStatement"; value: Expr }
  | { type: "OP"; op: OP, left: Expr, right: Expr }
  | { type: "If"; condition: Expr; then: Expr[] }
  | { type: "Console"; values: Expr[] };
```

And with that, we can write our parser:

```ts
import { Expr } from "./ast";
import { Type } from "./checker";
import { Token, TokenType } from "./lexer";

type ExtractToken<T extends Token["type"]> = Extract<Token, { type: T }>;

export class Parser {
  tokens: Token[];
  pos: number = 0;

  constructor(tokens: Token[]) {
    this.tokens = tokens;
  }

  private peek(): Token | null {
    return this.tokens[this.pos] || null;
  }

  private consume<T extends TokenType>(expected: T): ExtractToken<T> {
    const currentToken = this.peek();

    if (!currentToken) {
      throw new Error(`Expected: ${expected}, but found: Nothing`);
    }

    this.pos++;

    // type guard function to narrow down the type of the currentToken variable
    function isToken<T extends Token["type"]>(
      token: Token,
      type: T
    ): token is ExtractToken<T> {
      return token.type === type;
    }

    // use the type guard function to return the correct type
    if (isToken(currentToken, expected)) {
      return currentToken;
    }

    throw new Error(`Expected: ${expected}, but found: ${currentToken.type}`);
  }

  private parseVariable(): Expr {
    this.consume("VariableDeclaration");
    const name = this.consume("Literal");
    this.consume("Equal");

    const value: Expr = this.parseOne();
    const optionalSemicolon = this.peek();

    if (optionalSemicolon?.type === "SemiColon") {
      this.consume("SemiColon");
    }

    return { type: "Variable", name: name.value, value };
  }

  private parseTypeDeclaration(): Type {
    if (this.peek()?.type === "OpenParentheses") {
      this.consume("OpenParentheses");

      const paramsTy: Type[] = [];

      while (this.peek()?.type !== "CloseParentheses") {
        const ty = this.parseTypeDeclaration();
        paramsTy.push(ty);

        if (this.peek()?.type === "Comma") {
          this.consume("Comma");
        }
      }

      this.consume("CloseParentheses");
      this.consume("Arrow");
      const returnTy = this.parseTypeDeclaration();

      return { type: "Arrow", params: paramsTy, returnTy };
    } else {
      const ty = this.consume("TypeDeclaration");

      return ty.tyValue;
    }
  }

  private parseFunction(): Expr {
    this.consume("FunctionDeclaration");
    const name = this.consume("Literal");

    this.consume("OpenParentheses");

    const params: { name: string; ty: Type }[] = [];

    if (this.peek()?.type !== "CloseParentheses") {
      const lit = this.consume("Literal");
      this.consume("Colon");
      const ty = this.parseTypeDeclaration();
      params.push({ name: lit.value, ty });

      if (this.peek()?.type === "Comma") {
        while (this.peek()?.type !== "CloseParentheses") {
          this.consume("Comma");

          // calling this of newLit and newTy just to avoid shadowing
          const newLit = this.consume("Literal");
          this.consume("Colon");
          const newTy = this.parseTypeDeclaration();
          params.push({ name: newLit.value, ty: newTy });
        }
      }
    }

    this.consume("CloseParentheses");

    this.consume("Colon");
    const returnTy = this.parseTypeDeclaration();

    this.consume("OpenCurlyBracket");

    const body: Expr[] = [];

    while (this.peek()?.type !== "CloseCurlyBracket") {
      body.push(this.parseOne());
    }

    this.consume("CloseCurlyBracket");

    return {
      type: "Function",
      name: name.value,
      params: params,
      body,
      returnTy,
    };
  }

  private parseIf(): Expr {
    this.consume("IfDeclaration");

    this.consume("OpenParentheses");

    const condition = this.parseOne();

    this.consume("CloseParentheses");

    this.consume("OpenCurlyBracket");

    const then: Expr[] = [];

    while (this.peek()?.type !== "CloseCurlyBracket") {
      then.push(this.parseOne());
    }

    this.consume("CloseCurlyBracket");

    return { type: "If", condition, then };
  }

  private parseReturn(): Expr {
    this.consume("Return");
    const value = this.parseOne();
    const optionalSemicolon = this.peek();

    if (optionalSemicolon?.type === "SemiColon") {
      this.consume("SemiColon");
    }

    return { type: "ReturnStatement", value };
  }

  private parseFunctionApp(): Expr {
    const name = this.consume("Literal");
    this.consume("OpenParentheses");

    const params: Expr[] = [];

    if (this.peek()?.type !== "CloseParentheses") {
      params.push(this.parseOne());

      if (this.peek()?.type === "Comma") {
        while (this.peek()?.type !== "CloseParentheses") {
          this.consume("Comma");
          params.push(this.parseOne());
        }
      }
    }

    this.consume("CloseParentheses");

    const optionalSemicolon = this.peek();

    if (optionalSemicolon?.type === "SemiColon") {
      this.consume("SemiColon");
    }

    if (name.value === "radinho") {
      return { type: "Console", values: params };
    }

    return { type: "FunctionApp", functionName: name.value, params };
  }

  private parseOne(): Expr {
    if (this.peek()?.type === "VariableDeclaration")
      return this.parseVariable();

    if (this.peek()?.type === "FunctionDeclaration")
      return this.parseFunction();

    if (this.peek()?.type === "IfDeclaration") return this.parseIf();

    if (
      (this.peek()?.type === "OpenParentheses" &&
        this.tokens[this.pos + 1]?.type === "OP") ||
      this.peek()?.type === "OP"
    ) {
      const hasParentheses = this.peek()?.type === "OpenParentheses";

      if (hasParentheses) this.consume("OpenParentheses");

      const op = this.consume("OP");
      const left = this.parseOne();
      const right = this.parseOne();

      if (hasParentheses) this.consume("CloseParentheses");

      return {
        type: "OP",
        op: op.value,
        left,
        right,
      };
    }

    if (this.peek()?.type === "Return") return this.parseReturn();

    if (this.peek()?.type === "Literal") {
      const nextToken = this.tokens[this.pos + 1];

      if (nextToken?.type === "OpenParentheses") return this.parseFunctionApp();

      return this.consume("Literal");
    }

    if (this.peek()?.type === "String") return this.consume("String");

    if (this.peek()?.type === "Number") return this.consume("Number");

    if (this.peek()?.type === "Boolean") return this.consume("Boolean");

    throw new Error(`Unexpected token: ${JSON.stringify(this.peek())}`);
  }

  parse(): Expr[] {
    let result: Expr[] = [];

    while (this.peek()) {
      result.push(this.parseOne());
    }

    return result;
  }
}
```

Just a note: I'm using an array of expressions for this toy language, but that's not recommended; I'm just simplifying stuff here.

## Static analysis

Static analysis, often called semantic analysis in the context of compilers, is the next phase after parsing. While the lexer and parser 
ensure that the source code adheres to the language's syntax, the semantic analysis phase further verifies that the program makes sense 
regarding the language's semantics or meaning.

In other words, the semantic analyzer checks that the parsed code is well-formed, meaningful, and logically coherent. This involves 
checking various aspects of the code that must be more concerned with syntax.

Here are some of the tasks that can be part of semantic analysis:

- Type checking
- Scope resolution
- Control flow checks
- Other language-specific checks

Errors caught in this stage can include type mismatch, undefined variables, improper use of operations, and unreachable code. If any 
semantic errors are found, the compiler reports them to the user.

Here you can see the basic type checker implementation that I did:

```ts
import { Expr } from "./ast";
import { deepEqual } from "./utils";

export type Type =
  | { type: "String" }
  | { type: "Number" }
  | { type: "Boolean" }
  | { type: "Void" }
  | { type: "Arrow"; params: Type[]; returnTy: Type };

type TyContext = { name: string; value: Type }[];

type BasicTypesExpr =
  | Extract<Expr, { type: "String" }>
  | Extract<Expr, { type: "Number" }>
  | Extract<Expr, { type: "Boolean" }>;

const checkStrictEqualParams = (params1: Type[], params2: Type[]): boolean => {
  if (params1.length === 0 && params2.length === 0) return true;

  const [current1, ...rest1] = params1;
  const [current2, ...rest2] = params2;

  if (deepEqual(current1, current2))
    return checkStrictEqualParams(rest1, rest2);

  return false;
};

const equal = (ty1: Type, ty2: Type): boolean => {
  if (ty1.type === "Arrow" && ty2.type === "Arrow") {
    if (
      equal(ty1.returnTy, ty2.returnTy) &&
      checkStrictEqualParams(ty1.params, ty2.params)
    )
      return true;

    return false;
  }

  if (ty1.type === ty2.type) return true;

  return false;
};

const isBasicType = (expr: Expr): expr is BasicTypesExpr =>
  ["String", "Number", "Boolean"].includes(expr.type);

const inferBasicTypes = (basicType: BasicTypesExpr): Type => {
  if (basicType.type === "String") return { type: "String" };

  if (basicType.type === "Number") return { type: "Number" };

  // Boolean
  return { type: "Boolean" };
};

const inferOp = (
  op: Extract<Expr, { type: "OP" }>,
  context: TyContext
): Type => {
  // Boolean OPs
  if (["==", "!=", ">", ">=", "<", "<="].includes(op.op)) {
    const leftTy = infer(op.left, context);
    const rightTy = infer(op.right, context);

    if (equal(leftTy, rightTy)) return { type: "Boolean" };

    throw new Error(
      `Type Mismatch in ${JSON.stringify(
        op.op
      )}, This condition will always return 'false' since the types have no overlap.`
    );
  }

  if (op.op === "+") {
    const leftTy = infer(op.left, context);
    const rightTy = infer(op.right, context);

    if (equal(leftTy, { type: "Number" }) && equal(rightTy, { type: "Number" }))
      return { type: "Number" };

    // Concat
    if (equal(leftTy, { type: "String" }) && equal(rightTy, { type: "String" }))
      return { type: "String" };

    throw new Error(
      `Type Error, both sides of this operation: ${JSON.stringify(
        op.op
      )} should have type number`
    );
  }

  // Math OPs
  const leftTy = infer(op.left, context);
  const rightTy = infer(op.right, context);

  if (equal(leftTy, { type: "Number" }) && equal(rightTy, { type: "Number" }))
    return { type: "Number" };

  throw new Error(
    `Type Error, both sides of this operation: ${JSON.stringify(
      op.op
    )} should have type number`
  );
};

const inferFunctionApp = (
  functionApp: Extract<Expr, { type: "FunctionApp" }>,
  context: TyContext
): Type => {
  const f = context.find(
    (item) => item.name === functionApp.functionName
  )?.value;

  if (!f)
    throw new Error(
      `Type Error, Cannot found: ${JSON.stringify(functionApp.functionName)}`
    );

  if (f.type !== "Arrow")
    throw new Error(
      `Type Error, ${JSON.stringify(
        functionApp.functionName
      )} is not a function.`
    );

  const paramsTypes = functionApp.params.map((param) => {
    if (isBasicType(param)) return inferBasicTypes(param);

    if (param.type === "OP") return inferOp(param, context);

    if (param.type === "FunctionApp") return inferFunctionApp(param, context);

    if (param.type === "Literal") {
      const ty = context.find((item) => item.name === param.value)?.value;

      if (!ty)
        throw new Error(
          `Type Error, Cannot found: ${JSON.stringify(param.value)}`
        );

      return ty;
    }

    if (param.type === "Function") {
      const exprAlreadyExist = context.find((item) => item.name === param.name);

      if (exprAlreadyExist) {
        throw new Error(`Function: ${param.name} already exist`);
      }

      const paramsExprAlreadyExist = param.params
        .map((param) => context.find((item) => item.name === param.name))
        .filter(
          (
            item
          ): item is {
            name: string;
            value: Type;
          } => item !== undefined
        );

      if (paramsExprAlreadyExist.length > 0) {
        throw new Error(`Invalid param name in function: ${param.name}`);
      }

      const paramsContext: TyContext = param.params.map(
        (param): { name: string; value: Type } => ({
          name: param.name,
          value: param.ty,
        })
      );

      // Dirty (and lazy) hack to allow recursion
      const internalContext: TyContext = [
        {
          name: param.name,
          value: {
            type: "Arrow",
            params: param.params.map((param) => param.ty),
            returnTy: param.returnTy,
          },
        },
        ...paramsContext,
        ...context,
      ];

      return inferFunction(param, internalContext);
    }

    throw new Error(
      `Unexpected Expression: ${JSON.stringify(
        param.type
      )}, this can't be used as param type`
    );
  });

  if (deepEqual(paramsTypes, f.params)) return f.returnTy;

  throw new Error(`Type Error, wrong param types`);
};

const inferLiteral = (
  literal: Extract<Expr, { type: "Literal" }>,
  context: TyContext
): Type => {
  const ty = context.find((item) => item.name === literal.value)?.value;

  if (!ty)
    throw new Error(
      `Type Error, Cannot found: ${JSON.stringify(literal.value)}`
    );

  return ty;
};

const inferVariable = (
  variable: Extract<Expr, { type: "Variable" }>,
  context: TyContext
): Type => {
  const ty = infer(variable.value, context);

  return ty;
};

// I'll make if conditions always return something for now (since I'm not exporting the Void type for users)
const inferIf = (
  ifExpr: Extract<Expr, { type: "If" }>,
  context: TyContext
): Type => {
  const conditionTy = infer(ifExpr.condition, context);

  if (conditionTy.type !== "Boolean")
    throw new Error(`Type Error, If condition should be a boolean`);

  const returnStatement = ifExpr.then.find(
    (expr) => expr.type === "ReturnStatement"
  );

  if (!returnStatement)
    throw new Error(
      `Type Error, If conditions should have an return statement`
    );

  const returnTy = infer(returnStatement, context);

  const nestedIfStatements = ifExpr.then.filter((expr) => expr.type === "If");

  if (nestedIfStatements) {
    const nestedIfStatementsTy = nestedIfStatements.map((nestedIf) =>
      infer(nestedIf, context)
    );

    if (
      !nestedIfStatementsTy.every((nestedIfTy) => equal(nestedIfTy, returnTy))
    ) {
      throw new Error(
        `Type Error, we don't have union types :(, so you can't return two different types`
      );
    }
  }

  const _ = check(ifExpr.then, context);

  return returnTy;
};

const inferFunction = (
  functionExpr: Extract<Expr, { type: "Function" }>,
  context: TyContext
): Type => {
  const paramsTy = functionExpr.params.map((param) => param.ty);

  const returnStatement = functionExpr.body.find(
    (expr) => expr.type === "ReturnStatement"
  );

  if (!returnStatement)
    throw new Error(`Type Error, Functions should have an return statement`);

  const returnTy = infer(returnStatement, context);

  const ifStatements = functionExpr.body.filter((expr) => expr.type === "If");

  if (ifStatements) {
    const ifStatementsTy = ifStatements.map((ifStatement) =>
      infer(ifStatement, context)
    );

    if (!ifStatementsTy.every((ifTy) => equal(ifTy, returnTy))) {
      throw new Error(
        `Type Error, we don't have union types :(, so you can't return two different types`
      );
    }
  }

  if (!equal(functionExpr.returnTy, returnTy)) {
    throw new Error(
      `Type Error, expected: ${JSON.stringify(
        functionExpr.returnTy
      )}, received: ${JSON.stringify(returnTy)}`
    );
  }

  const _ = check(functionExpr.body, context);

  return { type: "Arrow", params: paramsTy, returnTy };
};

const inferConsole = (
  console: Extract<Expr, { type: "Console" }>,
  context: TyContext
): Type => {
  if (console.values.length <= 0) {
    throw new Error("Radinho should have at least one value");
  }

  const _ = check(console.values, context);

  return { type: "Void" };
};

export const infer = (expr: Expr, context: TyContext): Type => {
  if (expr.type === "Literal") return inferLiteral(expr, context);

  if (isBasicType(expr)) return inferBasicTypes(expr);

  if (expr.type === "Variable") return inferVariable(expr, context);

  if (expr.type === "OP") return inferOp(expr, context);

  if (expr.type === "If") return inferIf(expr, context);

  if (expr.type === "Function") return inferFunction(expr, context);

  if (expr.type === "FunctionApp") return inferFunctionApp(expr, context);

  if (expr.type === "Console") return inferConsole(expr, context);

  // Return Statement
  return infer(expr.value, context);
};

export const check = (exprs: Expr[], context: TyContext): [true, TyContext] => {
  try {
    const [current, ...rest] = exprs;
    const isLastExpr = !rest?.[0];

    if (!current) return [true, context];

    if (current.type === "Variable") {
      const exprAlreadyExist = context.find(
        (item) => item.name === current.name
      );

      if (exprAlreadyExist) {
        throw new Error(`Variable: ${current.name} already exist`);
      }

      const ty = infer(current, context);

      const newContext = [{ name: current.name, value: ty }, ...context];

      if (isLastExpr) return [true, newContext];

      return check(rest, newContext);
    }

    if (current.type === "Function") {
      const exprAlreadyExist = context.find(
        (item) => item.name === current.name
      );

      if (exprAlreadyExist) {
        throw new Error(`Function: ${current.name} already exist`);
      }

      const paramsExprAlreadyExist = current.params
        .map((param) => context.find((item) => item.name === param.name))
        .filter(
          (
            item
          ): item is {
            name: string;
            value: Type;
          } => item !== undefined
        );

      if (paramsExprAlreadyExist.length > 0) {
        throw new Error(`Invalid param name in function: ${current.name}`);
      }

      const paramsContext: TyContext = current.params.map(
        (param): { name: string; value: Type } => ({
          name: param.name,
          value: param.ty,
        })
      );

      // Dirty (and lazy) hack to allow recursion
      const internalContext: TyContext = [
        {
          name: current.name,
          value: {
            type: "Arrow",
            params: current.params.map((param) => param.ty),
            returnTy: current.returnTy,
          },
        },
        ...paramsContext,
        ...context,
      ];

      const ty = infer(current, internalContext);

      const newContext = [{ name: current.name, value: ty }, ...context];

      if (isLastExpr) return [true, newContext];

      return check(rest, newContext);
    }

    const _ = infer(current, context);

    if (isLastExpr) return [true, context];

    return check(rest, context);
  } catch (err) {
    if (err instanceof Error) throw new Error(err.message);

    throw new Error(`Unexpected type error, ${JSON.stringify(err)}`);
  }
};
```

Just a note: Like the lexer, this could be way more efficient and faster; I did it to make it work as simply as possible.

## Intermediate representation and Optimization

The intermediate representation (IR) is essential to the compilation process. After the source code has been lexed, parsed, and 
semantically analyzed, the next step is to translate it into an intermediate form.

The intermediate representation is a generic form of code that abstracts the specifics of the source language and the target machine language. 
It is designed to be easy for the compiler to manipulate and analyze, making it a powerful tool for optimization. Additionally, using an intermediate 
representation, compilers can be modularized more effectively, separating the front end (language-specific) and the back end (machine-specific).

There are two main types of intermediate representation: high-level IRs and low-level IRs.

- **High-Level IR**: This form of IR is closer to the structure of the source code. It maintains much of the high-level abstraction of the source language, 
which can be helpful for certain kinds of analysis and optimization.

- **Low-Level IR**: This form of IR is closer to the machine code and is more abstract than high-level IR. It's typically used for optimizations that rely more 
on the target machine's specifics and for generating machine code in the final step of the compilation process.

The compiler manipulates the intermediate representation to optimize the code. Optimizations can be as simple as eliminating redundant computations and dead code 
or as complex as loop transformations and inline expansion. These optimizations aim to improve the resulting program's performance, reducing runtime, memory usage, 
power consumption, or some combination of these.

## Code generation and/or runtime

The final stages of a compiler's operation focus on Code Generation and, potentially, Runtime Management. Let's take a closer look at each.

#### Code generation

- At this point, we've been through all the stages of analysis and abstraction, optimized the code using the intermediate representation, 
and now it's time to generate the target code. This could be machine code for a specific hardware architecture, but it could also be another high-level language.

- The goal of the code generator is to take the intermediate code and transform it into efficient code in the target language. This can involve mapping constructs 
from the source language to equivalent constructs in the target language, ensuring that the semantics of the original code are preserved in the translation.

- For instance, if you're transpiling TypeScript to JavaScript, the compiler needs to decide how to translate TypeScript's static typing system into JavaScript, 
which is dynamically typed. Similarly, if you're compiling a functional language to an imperative language, the compiler must figure out how to represent functional 
programming constructs using the imperative language's features.

#### Runtime management

- Depending on the source and target languages, the compiler may also need to generate code to manage the runtime environment. This can include setting up stacks 
and heaps for dynamic memory allocation, managing the invocation and return of functions (including parameter passing), handling exceptions, and potentially 
implementing some form of garbage collection for languages that support it.

Here you can see the basic printer implementation that I did to emit javascript from my "AST":

```ts
import { Expr } from "./ast";

export type Doc =
  | { type: "Nil" }
  | { type: ":<>"; left: Doc; right: Doc }
  | { type: "Nest"; index: number; doc: Doc }
  | { type: "Text"; value: string }
  | { type: "Line" };

const append = (left: Doc, right: Doc): Doc => {
  return { type: ":<>", left, right };
};

export type DocNormalForm =
  | { type: "Nil" }
  | { type: "Text"; value: string; doc: DocNormalForm }
  | { type: "Line"; index: number; doc: DocNormalForm };

const copy = (i: number, x: string): string => Array(i).fill(x).join("");

const nil = (): Doc => {
  return { type: "Nil" };
};

const nest = (index: number, doc: Doc): Doc => {
  return { type: "Nest", index, doc };
};

const text = (value: string): Doc => {
  return { type: "Text", value };
};

const line = (): Doc => {
  return { type: "Line" };
};

const space = (): Doc => {
  return { type: "Text", value: " " };
};

const folddoc = (f: (x: Doc, y: Doc) => Doc, docs: Doc[]): Doc => {
  if (docs.length === 1 && docs[0]) return docs[0];

  const [x, ...xs] = docs;

  if (x) {
    return f(x, folddoc(f, xs));
  }

  return nil();
};

const layout = (doc: DocNormalForm): string => {
  if (doc.type === "Text") {
    return doc.value + layout(doc.doc);
  }

  if (doc.type === "Line") {
    return "\n" + copy(doc.index, " ") + layout(doc.doc);
  }

  return "";
};

const be = (index: number, docs: [number, Doc][]): DocNormalForm => {
  const [x, ...xs] = docs;

  if (x) {
    const [i, doc] = x;

    if (doc.type === "Nil") return be(index, xs);

    if (doc.type === ":<>") {
      const first: [number, Doc] = [i, doc.left];
      const second: [number, Doc] = [i, doc.right];

      return be(index, [first, second, ...xs]);
    }

    if (doc.type === "Nest") {
      const first: [number, Doc] = [i + doc.index, doc.doc];

      return be(index, [first, ...xs]);
    }

    if (doc.type === "Text") {
      return {
        type: "Text",
        value: doc.value,
        doc: be(index + doc.value.length, xs),
      };
    }

    return { type: "Line", index: i, doc: be(i, xs) };
  }

  return { type: "Nil" };
};

const best = (index: number, doc: Doc): DocNormalForm => be(index, [[0, doc]]);

const pretty = (doc: Doc): string => layout(best(0, doc));

const parametersToDoc = (params: string[]): Doc => {
  if (params.length === 1 && params[0]) return text(params[0]);

  const [param, ...xs] = params;

  if (param) {
    return append(
      text(param),
      append(text(","), append(space(), parametersToDoc(xs)))
    );
  }

  return nil();
};

const convertExprsInSequence = (exprs: Expr[]): Doc => {
  if (exprs.length === 1 && exprs[0]) return printExpr(exprs[0]);

  const [expr, ...xs] = exprs;

  if (expr) {
    return append(
      printExpr(expr),
      append(text(","), append(space(), convertExprsInSequence(xs)))
    );
  }

  return nil();
};

const printExprs = (exprs: Expr[]): Doc => {
  if (exprs.length === 1 && exprs[0]) return printExpr(exprs[0]);

  const [expr, ...xs] = exprs;

  if (expr) {
    return append(
      printExpr(expr),
      append(line(), append(line(), printExprs(xs)))
    );
  }

  return nil();
};

const printExpr = (expr: Expr): Doc => {
  if (expr.type === "String") {
    return append(text('"'), append(text(expr.value), text('"')));
  }

  if (expr.type === "Number") {
    return text(expr.value.toString());
  }

  if (expr.type === "Boolean") {
    return text(expr.value.toString());
  }

  if (expr.type === "Literal") {
    return text(expr.value);
  }

  if (expr.type === "Variable") {
    return append(
      text("const"),
      append(
        space(),
        append(
          text(expr.name),
          append(
            space(),
            append(
              text("="),
              append(space(), append(printExpr(expr.value), text(";")))
            )
          )
        )
      )
    );
  }

  if (expr.type === "Function") {
    return append(
      text("function"),
      append(
        space(),
        append(
          text(expr.name),
          append(
            text("("),
            append(
              parametersToDoc(expr.params.map((param) => param.name)),
              append(
                text(")"),
                append(
                  space(),
                  append(
                    text("{"),
                    append(
                      nest(2, append(line(), printExprs(expr.body))),
                      append(line(), text("}"))
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  }

  if (expr.type === "FunctionApp") {
    return append(
      text(expr.functionName),
      append(text("("), append(convertExprsInSequence(expr.params), text(")")))
    );
  }

  if (expr.type === "ReturnStatement") {
    return append(
      text("return"),
      append(space(), append(printExpr(expr.value), text(";")))
    );
  }

  if (expr.type === "OP") {
    return append(
      printExpr(expr.left),
      append(
        space(),
        append(text(expr.op), append(space(), printExpr(expr.right)))
      )
    );
  }

  if (expr.type === "If") {
    return append(
      text("if"),
      append(
        space(),
        append(
          text("("),
          append(
            printExpr(expr.condition),
            append(
              text(")"),
              append(
                space(),
                append(
                  text("{"),
                  append(
                    nest(2, append(line(), printExprs(expr.then))),
                    append(line(), text("}"))
                  )
                )
              )
            )
          )
        )
      )
    );
  }

  if (expr.type === "Console") {
    return append(
      text("console.log"),
      append(
        text("("),
        append(
          convertExprsInSequence(expr.values),
          append(text(")"), text(";"))
        )
      )
    );
  }

  return nil();
};

export const printer = (exprs: Expr[]): string => pretty(printExprs(exprs));
```

## Conclusion

The design and implementation of compilers (or transpilers) is a complex and fascinating subject, exploring the intersection of theory and practice, language design, 
and software engineering. It offers a unique insight into the workings of programming languages and the translation between them.

Here you can see the complete source code of the toy language described in this post: [source code](https://github.com/Guilherme775/Cria)